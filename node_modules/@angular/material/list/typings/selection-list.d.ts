/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { FocusableOption, FocusKeyManager } from '@angular/cdk/a11y';
import { SelectionModel } from '@angular/cdk/collections';
import { AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, OnInit, QueryList } from '@angular/core';
import { CanDisable, CanDisableRipple, MatLine } from '@angular/material/core';
import { ControlValueAccessor } from '@angular/forms';
/** @docs-private */
import * as ɵngcc0 from '@angular/core';
export declare class MatSelectionListBase {
}
export declare const _MatSelectionListMixinBase: (new (...args: any[]) => CanDisableRipple) & (new (...args: any[]) => CanDisable) & typeof MatSelectionListBase;
/** @docs-private */
export declare class MatListOptionBase {
}
export declare const _MatListOptionMixinBase: (new (...args: any[]) => CanDisableRipple) & typeof MatListOptionBase;
/** @docs-private */
export declare const MAT_SELECTION_LIST_VALUE_ACCESSOR: any;
/**
 * Change event object emitted by MatListOption whenever the selected state changes.
 * @deprecated Use the `MatSelectionListChange` event on the selection list instead.
 * @deletion-target 6.0.0
 */
export declare class MatListOptionChange {
    /** Reference to the list option that changed. */
    source: MatListOption;
    /** The new selected state of the option. */
    selected: boolean;
    constructor(
        /** Reference to the list option that changed. */
        source: MatListOption, 
        /** The new selected state of the option. */
        selected: boolean);
}
/** Change event that is being fired whenever the selected state of an option changes. */
export declare class MatSelectionListChange {
    /** Reference to the selection list that emitted the event. */
    source: MatSelectionList;
    /** Reference to the option that has been changed. */
    option: MatListOption;
    constructor(
        /** Reference to the selection list that emitted the event. */
        source: MatSelectionList, 
        /** Reference to the option that has been changed. */
        option: MatListOption);
}
/**
 * Component for list-options of selection-list. Each list-option can automatically
 * generate a checkbox and can put current item into the selectionModel of selection-list
 * if the current item is selected.
 */
export declare class MatListOption extends _MatListOptionMixinBase implements AfterContentInit, OnDestroy, OnInit, FocusableOption, CanDisableRipple {
    private _element;
    private _changeDetector;
    /** @docs-private */
    selectionList: MatSelectionList;
    private _selected;
    private _disabled;
    /** Whether the option has focus. */
    _hasFocus: boolean;
    _lines: QueryList<MatLine>;
    /** DOM element containing the item's text. */
    _text: ElementRef;
    /** Whether the label should appear before or after the checkbox. Defaults to 'after' */
    checkboxPosition: 'before' | 'after';
    /** Value of the option */
    value: any;
    /** Whether the option is disabled. */
    disabled: any;
    /** Whether the option is selected. */
    selected: boolean;
    /**
     * Emits a change event whenever the selected state of an option changes.
     * @deprecated Use the `selectionChange` event on the `<mat-selection-list>` instead.
     * @deletion-target 6.0.0
     */
    readonly selectionChange: EventEmitter<MatListOptionChange>;
    constructor(_element: ElementRef, _changeDetector: ChangeDetectorRef, 
        /** @docs-private */
        selectionList: MatSelectionList);
    ngOnInit(): void;
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    /** Toggles the selection state of the option. */
    toggle(): void;
    /** Allows for programmatic focusing of the option. */
    focus(): void;
    /**
     * Returns the list item's text label. Implemented as a part of the FocusKeyManager.
     * @docs-private
     */
    getLabel(): any;
    /** Whether this list item should show a ripple effect when clicked. */
    _isRippleDisabled(): any;
    _handleClick(): void;
    _handleFocus(): void;
    _handleBlur(): void;
    /** Retrieves the DOM element of the component host. */
    _getHostElement(): HTMLElement;
    /** Sets the selected state of the option. */
    _setSelected(selected: boolean): void;
    /** Emits a selectionChange event for this option. */
    _emitDeprecatedChangeEvent(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatListOption, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatListOption, "mat-list-option", ["matListOption"], { "disableRipple": "disableRipple"; "checkboxPosition": "checkboxPosition"; "disabled": "disabled"; "selected": "selected"; "value": "value"; }, { "selectionChange": "selectionChange"; }, ["_lines"], ["*"]>;
}
/**
 * Material Design list component where each item is a selectable option. Behaves as a listbox.
 */
export declare class MatSelectionList extends _MatSelectionListMixinBase implements FocusableOption, CanDisable, CanDisableRipple, AfterContentInit, ControlValueAccessor, OnDestroy {
    private _element;
    /** The FocusKeyManager which handles focus. */
    _keyManager: FocusKeyManager<MatListOption>;
    /** The option components contained within this selection-list. */
    options: QueryList<MatListOption>;
    /** Emits a change event whenever the selected state of an option changes. */
    readonly selectionChange: EventEmitter<MatSelectionListChange>;
    /** Tabindex of the selection list. */
    tabIndex: number;
    /** The currently selected options. */
    selectedOptions: SelectionModel<MatListOption>;
    /** View to model callback that should be called whenever the selected options change. */
    private _onChange;
    /** Used for storing the values that were assigned before the options were initialized. */
    private _tempValues;
    private _modelChanges;
    /** View to model callback that should be called if the list or its options lost focus. */
    _onTouched: () => void;
    constructor(_element: ElementRef, tabIndex: string);
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    /** Focuses the last active list option. */
    focus(): void;
    /** Selects all of the options. */
    selectAll(): void;
    /** Deselects all of the options. */
    deselectAll(): void;
    /** Sets the focused option of the selection-list. */
    _setFocusedOption(option: MatListOption): void;
    /** Removes an option from the selection list and updates the active item. */
    _removeOptionFromList(option: MatListOption): void;
    /** Passes relevant key presses to our key manager. */
    _keydown(event: KeyboardEvent): void;
    /** Reports a value change to the ControlValueAccessor */
    _reportValueChange(): void;
    /** Emits a change event if the selected state of an option changed. */
    _emitChangeEvent(option: MatListOption): void;
    /** Implemented as part of ControlValueAccessor. */
    writeValue(values: string[]): void;
    /** Implemented as a part of ControlValueAccessor. */
    setDisabledState(isDisabled: boolean): void;
    /** Implemented as part of ControlValueAccessor. */
    registerOnChange(fn: (value: any) => void): void;
    /** Implemented as part of ControlValueAccessor. */
    registerOnTouched(fn: () => void): void;
    /** Returns the option with the specified value. */
    private _getOptionByValue(value);
    /** Sets the selected options based on the specified values. */
    private _setOptionsFromValues(values);
    /** Returns the values of the selected options. */
    private _getSelectedOptionValues();
    /** Toggles the selected state of the currently focused option. */
    private _toggleSelectOnFocusedOption();
    /**
     * Utility to ensure all indexes are valid.
     * @param index The index to be checked.
     * @returns True if the index is valid for our list of options.
     */
    private _isValidIndex(index);
    /** Returns the index of the specified list option. */
    private _getOptionIndex(option);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatSelectionList, [null, { attribute: "tabindex"; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatSelectionList, "mat-selection-list", ["matSelectionList"], { "disabled": "disabled"; "disableRipple": "disableRipple"; "tabIndex": "tabIndex"; }, { "selectionChange": "selectionChange"; }, ["options"], ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLWxpc3QuZC50cyIsInNvdXJjZXMiOlsic2VsZWN0aW9uLWxpc3QuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgRm9jdXNhYmxlT3B0aW9uLCBGb2N1c0tleU1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDYW5EaXNhYmxlLCBDYW5EaXNhYmxlUmlwcGxlLCBNYXRMaW5lIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXRTZWxlY3Rpb25MaXN0QmFzZSB7XG59XG5leHBvcnQgZGVjbGFyZSBjb25zdCBfTWF0U2VsZWN0aW9uTGlzdE1peGluQmFzZTogKG5ldyAoLi4uYXJnczogYW55W10pID0+IENhbkRpc2FibGVSaXBwbGUpICYgKG5ldyAoLi4uYXJnczogYW55W10pID0+IENhbkRpc2FibGUpICYgdHlwZW9mIE1hdFNlbGVjdGlvbkxpc3RCYXNlO1xuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE1hdExpc3RPcHRpb25CYXNlIHtcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IF9NYXRMaXN0T3B0aW9uTWl4aW5CYXNlOiAobmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gQ2FuRGlzYWJsZVJpcHBsZSkgJiB0eXBlb2YgTWF0TGlzdE9wdGlvbkJhc2U7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgTUFUX1NFTEVDVElPTl9MSVNUX1ZBTFVFX0FDQ0VTU09SOiBhbnk7XG4vKipcbiAqIENoYW5nZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSBNYXRMaXN0T3B0aW9uIHdoZW5ldmVyIHRoZSBzZWxlY3RlZCBzdGF0ZSBjaGFuZ2VzLlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgTWF0U2VsZWN0aW9uTGlzdENoYW5nZWAgZXZlbnQgb24gdGhlIHNlbGVjdGlvbiBsaXN0IGluc3RlYWQuXG4gKiBAZGVsZXRpb24tdGFyZ2V0IDYuMC4wXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE1hdExpc3RPcHRpb25DaGFuZ2Uge1xuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGxpc3Qgb3B0aW9uIHRoYXQgY2hhbmdlZC4gKi9cbiAgICBzb3VyY2U6IE1hdExpc3RPcHRpb247XG4gICAgLyoqIFRoZSBuZXcgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIG9wdGlvbi4gKi9cbiAgICBzZWxlY3RlZDogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgbGlzdCBvcHRpb24gdGhhdCBjaGFuZ2VkLiAqL1xuICAgICAgICBzb3VyY2U6IE1hdExpc3RPcHRpb24sIFxuICAgICAgICAvKiogVGhlIG5ldyBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgb3B0aW9uLiAqL1xuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbik7XG59XG4vKiogQ2hhbmdlIGV2ZW50IHRoYXQgaXMgYmVpbmcgZmlyZWQgd2hlbmV2ZXIgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIGFuIG9wdGlvbiBjaGFuZ2VzLiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWF0U2VsZWN0aW9uTGlzdENoYW5nZSB7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgc2VsZWN0aW9uIGxpc3QgdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICBzb3VyY2U6IE1hdFNlbGVjdGlvbkxpc3Q7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3B0aW9uIHRoYXQgaGFzIGJlZW4gY2hhbmdlZC4gKi9cbiAgICBvcHRpb246IE1hdExpc3RPcHRpb247XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHNlbGVjdGlvbiBsaXN0IHRoYXQgZW1pdHRlZCB0aGUgZXZlbnQuICovXG4gICAgICAgIHNvdXJjZTogTWF0U2VsZWN0aW9uTGlzdCwgXG4gICAgICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIG9wdGlvbiB0aGF0IGhhcyBiZWVuIGNoYW5nZWQuICovXG4gICAgICAgIG9wdGlvbjogTWF0TGlzdE9wdGlvbik7XG59XG4vKipcbiAqIENvbXBvbmVudCBmb3IgbGlzdC1vcHRpb25zIG9mIHNlbGVjdGlvbi1saXN0LiBFYWNoIGxpc3Qtb3B0aW9uIGNhbiBhdXRvbWF0aWNhbGx5XG4gKiBnZW5lcmF0ZSBhIGNoZWNrYm94IGFuZCBjYW4gcHV0IGN1cnJlbnQgaXRlbSBpbnRvIHRoZSBzZWxlY3Rpb25Nb2RlbCBvZiBzZWxlY3Rpb24tbGlzdFxuICogaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBzZWxlY3RlZC5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWF0TGlzdE9wdGlvbiBleHRlbmRzIF9NYXRMaXN0T3B0aW9uTWl4aW5CYXNlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95LCBPbkluaXQsIEZvY3VzYWJsZU9wdGlvbiwgQ2FuRGlzYWJsZVJpcHBsZSB7XG4gICAgcHJpdmF0ZSBfZWxlbWVudDtcbiAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvcjtcbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIHNlbGVjdGlvbkxpc3Q6IE1hdFNlbGVjdGlvbkxpc3Q7XG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWQ7XG4gICAgcHJpdmF0ZSBfZGlzYWJsZWQ7XG4gICAgLyoqIFdoZXRoZXIgdGhlIG9wdGlvbiBoYXMgZm9jdXMuICovXG4gICAgX2hhc0ZvY3VzOiBib29sZWFuO1xuICAgIF9saW5lczogUXVlcnlMaXN0PE1hdExpbmU+O1xuICAgIC8qKiBET00gZWxlbWVudCBjb250YWluaW5nIHRoZSBpdGVtJ3MgdGV4dC4gKi9cbiAgICBfdGV4dDogRWxlbWVudFJlZjtcbiAgICAvKiogV2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGFwcGVhciBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGNoZWNrYm94LiBEZWZhdWx0cyB0byAnYWZ0ZXInICovXG4gICAgY2hlY2tib3hQb3NpdGlvbjogJ2JlZm9yZScgfCAnYWZ0ZXInO1xuICAgIC8qKiBWYWx1ZSBvZiB0aGUgb3B0aW9uICovXG4gICAgdmFsdWU6IGFueTtcbiAgICAvKiogV2hldGhlciB0aGUgb3B0aW9uIGlzIGRpc2FibGVkLiAqL1xuICAgIGRpc2FibGVkOiBhbnk7XG4gICAgLyoqIFdoZXRoZXIgdGhlIG9wdGlvbiBpcyBzZWxlY3RlZC4gKi9cbiAgICBzZWxlY3RlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIGNoYW5nZSBldmVudCB3aGVuZXZlciB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgYW4gb3B0aW9uIGNoYW5nZXMuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgc2VsZWN0aW9uQ2hhbmdlYCBldmVudCBvbiB0aGUgYDxtYXQtc2VsZWN0aW9uLWxpc3Q+YCBpbnN0ZWFkLlxuICAgICAqIEBkZWxldGlvbi10YXJnZXQgNi4wLjBcbiAgICAgKi9cbiAgICByZWFkb25seSBzZWxlY3Rpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXRMaXN0T3B0aW9uQ2hhbmdlPjtcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudDogRWxlbWVudFJlZiwgX2NoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZiwgXG4gICAgICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgICAgIHNlbGVjdGlvbkxpc3Q6IE1hdFNlbGVjdGlvbkxpc3QpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKiogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIHN0YXRlIG9mIHRoZSBvcHRpb24uICovXG4gICAgdG9nZ2xlKCk6IHZvaWQ7XG4gICAgLyoqIEFsbG93cyBmb3IgcHJvZ3JhbW1hdGljIGZvY3VzaW5nIG9mIHRoZSBvcHRpb24uICovXG4gICAgZm9jdXMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IGl0ZW0ncyB0ZXh0IGxhYmVsLiBJbXBsZW1lbnRlZCBhcyBhIHBhcnQgb2YgdGhlIEZvY3VzS2V5TWFuYWdlci5cbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgZ2V0TGFiZWwoKTogYW55O1xuICAgIC8qKiBXaGV0aGVyIHRoaXMgbGlzdCBpdGVtIHNob3VsZCBzaG93IGEgcmlwcGxlIGVmZmVjdCB3aGVuIGNsaWNrZWQuICovXG4gICAgX2lzUmlwcGxlRGlzYWJsZWQoKTogYW55O1xuICAgIF9oYW5kbGVDbGljaygpOiB2b2lkO1xuICAgIF9oYW5kbGVGb2N1cygpOiB2b2lkO1xuICAgIF9oYW5kbGVCbHVyKCk6IHZvaWQ7XG4gICAgLyoqIFJldHJpZXZlcyB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIGNvbXBvbmVudCBob3N0LiAqL1xuICAgIF9nZXRIb3N0RWxlbWVudCgpOiBIVE1MRWxlbWVudDtcbiAgICAvKiogU2V0cyB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIG9wdGlvbi4gKi9cbiAgICBfc2V0U2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKiBFbWl0cyBhIHNlbGVjdGlvbkNoYW5nZSBldmVudCBmb3IgdGhpcyBvcHRpb24uICovXG4gICAgX2VtaXREZXByZWNhdGVkQ2hhbmdlRXZlbnQoKTogdm9pZDtcbn1cbi8qKlxuICogTWF0ZXJpYWwgRGVzaWduIGxpc3QgY29tcG9uZW50IHdoZXJlIGVhY2ggaXRlbSBpcyBhIHNlbGVjdGFibGUgb3B0aW9uLiBCZWhhdmVzIGFzIGEgbGlzdGJveC5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWF0U2VsZWN0aW9uTGlzdCBleHRlbmRzIF9NYXRTZWxlY3Rpb25MaXN0TWl4aW5CYXNlIGltcGxlbWVudHMgRm9jdXNhYmxlT3B0aW9uLCBDYW5EaXNhYmxlLCBDYW5EaXNhYmxlUmlwcGxlLCBBZnRlckNvbnRlbnRJbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIF9lbGVtZW50O1xuICAgIC8qKiBUaGUgRm9jdXNLZXlNYW5hZ2VyIHdoaWNoIGhhbmRsZXMgZm9jdXMuICovXG4gICAgX2tleU1hbmFnZXI6IEZvY3VzS2V5TWFuYWdlcjxNYXRMaXN0T3B0aW9uPjtcbiAgICAvKiogVGhlIG9wdGlvbiBjb21wb25lbnRzIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBzZWxlY3Rpb24tbGlzdC4gKi9cbiAgICBvcHRpb25zOiBRdWVyeUxpc3Q8TWF0TGlzdE9wdGlvbj47XG4gICAgLyoqIEVtaXRzIGEgY2hhbmdlIGV2ZW50IHdoZW5ldmVyIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiBhbiBvcHRpb24gY2hhbmdlcy4gKi9cbiAgICByZWFkb25seSBzZWxlY3Rpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXRTZWxlY3Rpb25MaXN0Q2hhbmdlPjtcbiAgICAvKiogVGFiaW5kZXggb2YgdGhlIHNlbGVjdGlvbiBsaXN0LiAqL1xuICAgIHRhYkluZGV4OiBudW1iZXI7XG4gICAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9ucy4gKi9cbiAgICBzZWxlY3RlZE9wdGlvbnM6IFNlbGVjdGlvbk1vZGVsPE1hdExpc3RPcHRpb24+O1xuICAgIC8qKiBWaWV3IHRvIG1vZGVsIGNhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc2VsZWN0ZWQgb3B0aW9ucyBjaGFuZ2UuICovXG4gICAgcHJpdmF0ZSBfb25DaGFuZ2U7XG4gICAgLyoqIFVzZWQgZm9yIHN0b3JpbmcgdGhlIHZhbHVlcyB0aGF0IHdlcmUgYXNzaWduZWQgYmVmb3JlIHRoZSBvcHRpb25zIHdlcmUgaW5pdGlhbGl6ZWQuICovXG4gICAgcHJpdmF0ZSBfdGVtcFZhbHVlcztcbiAgICBwcml2YXRlIF9tb2RlbENoYW5nZXM7XG4gICAgLyoqIFZpZXcgdG8gbW9kZWwgY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgY2FsbGVkIGlmIHRoZSBsaXN0IG9yIGl0cyBvcHRpb25zIGxvc3QgZm9jdXMuICovXG4gICAgX29uVG91Y2hlZDogKCkgPT4gdm9pZDtcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudDogRWxlbWVudFJlZiwgdGFiSW5kZXg6IHN0cmluZyk7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKiogRm9jdXNlcyB0aGUgbGFzdCBhY3RpdmUgbGlzdCBvcHRpb24uICovXG4gICAgZm9jdXMoKTogdm9pZDtcbiAgICAvKiogU2VsZWN0cyBhbGwgb2YgdGhlIG9wdGlvbnMuICovXG4gICAgc2VsZWN0QWxsKCk6IHZvaWQ7XG4gICAgLyoqIERlc2VsZWN0cyBhbGwgb2YgdGhlIG9wdGlvbnMuICovXG4gICAgZGVzZWxlY3RBbGwoKTogdm9pZDtcbiAgICAvKiogU2V0cyB0aGUgZm9jdXNlZCBvcHRpb24gb2YgdGhlIHNlbGVjdGlvbi1saXN0LiAqL1xuICAgIF9zZXRGb2N1c2VkT3B0aW9uKG9wdGlvbjogTWF0TGlzdE9wdGlvbik6IHZvaWQ7XG4gICAgLyoqIFJlbW92ZXMgYW4gb3B0aW9uIGZyb20gdGhlIHNlbGVjdGlvbiBsaXN0IGFuZCB1cGRhdGVzIHRoZSBhY3RpdmUgaXRlbS4gKi9cbiAgICBfcmVtb3ZlT3B0aW9uRnJvbUxpc3Qob3B0aW9uOiBNYXRMaXN0T3B0aW9uKTogdm9pZDtcbiAgICAvKiogUGFzc2VzIHJlbGV2YW50IGtleSBwcmVzc2VzIHRvIG91ciBrZXkgbWFuYWdlci4gKi9cbiAgICBfa2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQ7XG4gICAgLyoqIFJlcG9ydHMgYSB2YWx1ZSBjaGFuZ2UgdG8gdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yICovXG4gICAgX3JlcG9ydFZhbHVlQ2hhbmdlKCk6IHZvaWQ7XG4gICAgLyoqIEVtaXRzIGEgY2hhbmdlIGV2ZW50IGlmIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiBhbiBvcHRpb24gY2hhbmdlZC4gKi9cbiAgICBfZW1pdENoYW5nZUV2ZW50KG9wdGlvbjogTWF0TGlzdE9wdGlvbik6IHZvaWQ7XG4gICAgLyoqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKTogdm9pZDtcbiAgICAvKiogSW1wbGVtZW50ZWQgYXMgYSBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBhbnkpID0+IHZvaWQpOiB2b2lkO1xuICAgIC8qKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgICAvKiogUmV0dXJucyB0aGUgb3B0aW9uIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZS4gKi9cbiAgICBwcml2YXRlIF9nZXRPcHRpb25CeVZhbHVlKHZhbHVlKTtcbiAgICAvKiogU2V0cyB0aGUgc2VsZWN0ZWQgb3B0aW9ucyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIHZhbHVlcy4gKi9cbiAgICBwcml2YXRlIF9zZXRPcHRpb25zRnJvbVZhbHVlcyh2YWx1ZXMpO1xuICAgIC8qKiBSZXR1cm5zIHRoZSB2YWx1ZXMgb2YgdGhlIHNlbGVjdGVkIG9wdGlvbnMuICovXG4gICAgcHJpdmF0ZSBfZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZXMoKTtcbiAgICAvKiogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIGN1cnJlbnRseSBmb2N1c2VkIG9wdGlvbi4gKi9cbiAgICBwcml2YXRlIF90b2dnbGVTZWxlY3RPbkZvY3VzZWRPcHRpb24oKTtcbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIGVuc3VyZSBhbGwgaW5kZXhlcyBhcmUgdmFsaWQuXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGluZGV4IGlzIHZhbGlkIGZvciBvdXIgbGlzdCBvZiBvcHRpb25zLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2lzVmFsaWRJbmRleChpbmRleCk7XG4gICAgLyoqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgbGlzdCBvcHRpb24uICovXG4gICAgcHJpdmF0ZSBfZ2V0T3B0aW9uSW5kZXgob3B0aW9uKTtcbn1cbiJdfQ==